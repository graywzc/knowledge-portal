<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Knowledge Portal</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/styles/github-dark.min.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; display: flex; height: 100vh; background: #f5f5f5; color: #111; }

    body.dark { background: #0f1115; color: #e8eaed; }

    #sidebar { width: 280px; background: #1a1a2e; color: #eee; padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 16px; }
    #sidebar h2 { font-size: 14px; text-transform: uppercase; color: #888; margin-bottom: 4px; }
    #sidebar select { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #444; background: #16213e; color: #eee; font-size: 13px; }

    .tree-node { padding: 6px 8px; cursor: pointer; border-radius: 4px; font-size: 14px; }
    .tree-node:hover { background: rgba(255,255,255,0.1); }
    .tree-node.active { background: rgba(100,140,255,0.3); }
    .tree-children { margin-left: 16px; border-left: 1px solid #333; }

    #main { flex: 1; display: flex; flex-direction: column; }
    #layer-header { padding: 12px 20px; background: #fff; border-bottom: 1px solid #ddd; font-weight: 600; }
    #layer-header .back-link { display: inline-block; margin-left: 10px; font-weight: 500; font-size: 12px; color: #4a6cf7; cursor: pointer; text-decoration: none; }
    #layer-header .back-link:hover { text-decoration: underline; }
    #messages { flex: 1; overflow-y: auto; padding: 20px; }
    .msg { max-width: 760px; margin-bottom: 12px; padding: 10px 14px 22px 14px; border-radius: 12px; font-size: 14px; line-height: 1.5; position: relative; }
    .msg p { margin: 0 0 8px 0; }
    .msg p:last-child { margin-bottom: 0; }
    .msg pre { background: #0b1220; color: #dbe7ff; padding: 10px 12px; border-radius: 8px; overflow-x: auto; margin: 8px 0; }
    .msg code { background: rgba(74,108,247,0.12); padding: 1px 5px; border-radius: 5px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .msg pre code { background: transparent; padding: 0; border-radius: 0; font-size: 12px; }
    .msg table { width: 100%; border-collapse: collapse; margin: 8px 0; display: block; overflow-x: auto; }
    .msg th, .msg td { border: 1px solid #d7dbe5; padding: 6px 8px; text-align: left; white-space: nowrap; }
    .msg th { background: #eef2ff; }
    .msg blockquote { border-left: 3px solid #94a3b8; padding-left: 10px; margin: 8px 0; color: #4b5563; }
    .msg ul, .msg ol { padding-left: 20px; margin: 8px 0; }
    .msg.self { background: #d1e7ff; margin-left: auto; }
    .msg.other, .msg.bot { background: #fff; border: 1px solid #ddd; }
    .msg .meta { font-size: 11px; color: #888; margin-top: 4px; }
    .msg .time { position: absolute; right: 10px; bottom: 6px; font-size: 11px; color: #7a7a7a; }
    .msg .chat-id { position: absolute; left: 10px; bottom: 6px; font-size: 11px; color: #7a7a7a; opacity: 0.9; }

    body.dark #layer-header { background: #161a22; border-bottom-color: #2a2f3a; color: #e8eaed; }
    body.dark #layer-header .back-link { color: #8fb0ff; }
    body.dark #messages { background: #0f1115; }
    body.dark .msg.self { background: #214a73; color: #e8eaed; }
    body.dark .msg.other, body.dark .msg.bot { background: #1a1f29; border-color: #2f3644; color: #e8eaed; }
    body.dark .msg .meta { color: #a0a7b4; }
    body.dark .msg .time { color: #9aa4b2; }
    body.dark .msg .chat-id { color: #9aa4b2; }
    body.dark .msg code { background: rgba(143,176,255,0.18); }
    body.dark .msg table { color: #e8eaed; }
    body.dark .msg th, body.dark .msg td { border-color: #3a4458; }
    body.dark .msg th { background: #20283a; }
    body.dark .msg blockquote { color: #b8c2d4; border-left-color: #64748b; }
    .msg .branch-badge { display: inline-block; background: #4a6cf7; color: #fff; font-size: 10px; padding: 1px 6px; border-radius: 8px; margin-left: 6px; cursor: pointer; }

    #empty-state { flex: 1; display: flex; align-items: center; justify-content: center; color: #999; font-size: 16px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <div>
      <h2>Source</h2>
      <select id="source-select"><option value="">Select source...</option></select>
    </div>
    <div>
      <h2>Channel / Topic</h2>
      <select id="channel-select"><option value="">Select channel...</option></select>
      <div id="topic-list" style="margin-top:8px; display:none;"></div>
    </div>
    <div>
      <h2>Layers</h2>
      <div id="tree"></div>
    </div>
  </div>
  <div id="main">
    <div id="layer-header">Knowledge Portal</div>
    <div id="messages">
      <div id="empty-state">Select a source and channel to view messages</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/markdown-it@14/dist/markdown-it.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.10.0/lib/highlight.min.js"></script>
  <script>
    let currentSource = '';
    let currentChannel = '';
    let currentTopicName = '';
    let currentLayerId = 'A';
    let viewState = null;

    const md = window.markdownit({
      html: false,
      linkify: true,
      breaks: true,
      // Keep leading "#" as literal text instead of heading promotion.
      // This is important for labels/comments like "# class_id ..." in dataset snippets.
      }).disable(['heading', 'lheading']);

    md.set({
      highlight: (str, lang) => {
        try {
          if (lang && window.hljs && hljs.getLanguage(lang)) {
            return `<pre><code class="hljs language-${lang}">${hljs.highlight(str, { language: lang }).value}</code></pre>`;
          }
          if (window.hljs) {
            return `<pre><code class="hljs">${hljs.highlightAuto(str).value}</code></pre>`;
          }
        } catch (_) {}
        return `<pre><code>${escapeHtml(str)}</code></pre>`;
      },
    });

    function applyThemeByTime() {
      const h = new Date().getHours();
      const dark = (h >= 19 || h < 7);
      document.body.classList.toggle('dark', dark);
    }

    function formatMessageTime(ts) {
      const d = new Date(Number(ts));
      const now = new Date();
      const sameDay = d.getFullYear() === now.getFullYear() && d.getMonth() === now.getMonth() && d.getDate() === now.getDate();
      const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      if (sameDay) return time;
      const date = d.toLocaleDateString([], { month: 'numeric', day: 'numeric', year: '2-digit' });
      return `${date} ${time}`;
    }

    async function api(method, path, body) {
      const opts = { method, headers: { 'Content-Type': 'application/json' } };
      if (body) opts.body = JSON.stringify(body);
      const res = await fetch('/api' + path, opts);
      return res.json();
    }

    async function loadSources() {
      const sources = await api('GET', '/sources');
      const sel = document.getElementById('source-select');
      sel.innerHTML = '<option value="">Select source...</option>';
      sources.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s; opt.textContent = s;
        sel.appendChild(opt);
      });
    }

    async function loadChannels(source) {
      const channels = await api('GET', `/sources/${source}/channels`);
      const sel = document.getElementById('channel-select');
      sel.innerHTML = '<option value="">Select channel...</option>';
      channels.forEach(c => {
        const value = (typeof c === 'string') ? c : c.id;
        const label = (typeof c === 'string') ? c : (c.name || c.id);
        const opt = document.createElement('option');
        opt.value = value; opt.textContent = label;
        sel.appendChild(opt);
      });

      // For Telegram, show topic list ordered by most recent message.
      const topicList = document.getElementById('topic-list');
      if (source === 'telegram') {
        const topics = await api('GET', '/telegram/topics');
        topicList.style.display = 'block';
        topicList.innerHTML = '';
        topics.forEach(t => {
          const row = document.createElement('div');
          row.className = 'tree-node';
          row.textContent = `${t.name} (${t.messageCount})`;
          row.onclick = async () => {
            currentChannel = t.id;
            currentTopicName = t.name || '';
            sel.value = t.id;
            await loadView(currentSource, currentChannel);
          };
          topicList.appendChild(row);
        });
      } else {
        topicList.style.display = 'none';
        topicList.innerHTML = '';
      }
    }

    async function loadView(source, channel) {
      viewState = await api('GET', `/sources/${encodeURIComponent(source)}/channels/${encodeURIComponent(channel)}/view`);
      currentLayerId = viewState.currentLayerId;
      renderTree(viewState.tree);
      showLayer(currentLayerId);
    }

    function layerTitle(layerId) {
      if (layerId === 'A' && currentTopicName) return currentTopicName;
      const layer = viewState?.state?.layers?.[layerId];
      if (!layer || !layer.messages || layer.messages.length === 0) return `Layer ${layerId}`;
      const first = (layer.messages[0].content || '').replace(/\s+/g, ' ').trim();
      return first ? (first.length > 42 ? first.slice(0, 42) + '…' : first) : `Layer ${layerId}`;
    }

    function renderTree(node, container) {
      if (!container) {
        container = document.getElementById('tree');
        container.innerHTML = '';
      }
      if (!node) return;
      const div = document.createElement('div');
      div.className = 'tree-node' + (node.id === currentLayerId ? ' active' : '');
      div.textContent = layerTitle(node.id);
      div.title = `${layerTitle(node.id)} (${node.messageCount} msgs)`;
      div.onclick = (e) => { e.stopPropagation(); showLayer(node.id); };
      container.appendChild(div);

      if (node.children && node.children.length) {
        const childContainer = document.createElement('div');
        childContainer.className = 'tree-children';
        node.children.forEach(c => renderTree(c, childContainer));
        container.appendChild(childContainer);
      }
    }

    function showLayer(layerId, focusMessageId = null) {
      if (!viewState) return;
      currentLayerId = layerId;
      const layers = viewState.state.layers;
      const layer = layers[layerId];
      if (!layer) return;

      const header = document.getElementById('layer-header');
      const title = layerTitle(layerId);
      if (layer.parentLayerId && layer.branchFromMessageId) {
        header.innerHTML = `${escapeHtml(title)} <a class="back-link" onclick="showLayer('${layer.parentLayerId}', '${layer.branchFromMessageId}')">↩ back to parent msg #${escapeHtml(getShortChatId(layer.branchFromMessageId))}</a>`;
      } else {
        header.textContent = title;
      }

      const msgDiv = document.getElementById('messages');
      msgDiv.innerHTML = '';

      if (layer.messages.length === 0) {
        msgDiv.innerHTML = '<div id="empty-state">No messages in this layer</div>';
        return;
      }

      // Find which messages have child branches
      const branchPoints = {};
      for (const child of (layer.children || [])) {
        if (!branchPoints[child.branchFromMessageId]) branchPoints[child.branchFromMessageId] = [];
        branchPoints[child.branchFromMessageId].push(child.layerId);
      }

      layer.messages.forEach((m) => {
        const el = document.createElement('div');
        el.className = `msg ${m.sender}`;
        el.setAttribute('data-msg-id', m.id);
        let html = renderRichContent(m.content);
        html += `<div class="meta">${m.sender}`;
        if (m.replyToId) html += ` · reply to ${m.replyToId}`;
        if (branchPoints[m.id]) {
          branchPoints[m.id].forEach(childLayerId => {
            html += `<span class="branch-badge" onclick="showLayer('${childLayerId}')">→ ${childLayerId}</span>`;
          });
        }
        html += '</div>';
        html += `<div class="chat-id">id: ${escapeHtml(getShortChatId(m.id))}</div>`;
        html += `<div class="time">${formatMessageTime(m.timestamp)}</div>`;
        el.innerHTML = html;
        msgDiv.appendChild(el);
      });

      // Re-render tree to update active highlight
      if (viewState.tree) renderTree(viewState.tree);

      if (focusMessageId) {
        const target = msgDiv.querySelector(`[data-msg-id="${focusMessageId}"]`);
        if (target) {
          target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          target.style.outline = '2px solid #4a6cf7';
          setTimeout(() => { target.style.outline = ''; }, 1200);
        }
      }
    }

    function getShortChatId(messageId) {
      if (!messageId) return '';
      const s = String(messageId);
      const idx = s.lastIndexOf(':');
      return idx >= 0 ? s.slice(idx + 1) : s;
    }

    function preprocessMessageForMarkdown(text) {
      const s = String(text || '');
      if (!s.trim() || s.includes('```')) return s;

      // Preserve Telegram-style unicode/ASCII charts in a fixed-width block.
      const chartLike = /[│┤┼╭╮╯╰╲─→]/.test(s) && /\n/.test(s);
      if (chartLike) {
        return `\n\`\`\`text\n${s}\n\`\`\``;
      }

      const lines = s.split('\n');
      const commandStart = /^(?:\$\s*)?(?:npm|pnpm|yarn|node|python|pip|git|docker|kubectl|yolo|ffmpeg|curl|wget|cd|ls|cat|echo|export|source|make)\b/i;

      let i = 0;
      const out = [];
      while (i < lines.length) {
        if (commandStart.test(lines[i].trim())) {
          const block = [];
          while (i < lines.length && lines[i].trim() && commandStart.test(lines[i].trim())) {
            block.push(lines[i]);
            i++;
          }
          out.push('```shell');
          out.push(...block);
          out.push('```');
          continue;
        }
        out.push(lines[i]);
        i++;
      }
      return out.join('\n');
    }

    function renderRichContent(text) {
      try {
        const pre = preprocessMessageForMarkdown(text);
        const raw = md.render(pre);
        return DOMPurify.sanitize(raw);
      } catch (_) {
        return escapeHtml(String(text || ''));
      }
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }

    document.getElementById('source-select').onchange = async (e) => {
      currentSource = e.target.value;
      if (currentSource) await loadChannels(currentSource);
    };

    document.getElementById('channel-select').onchange = async (e) => {
      currentChannel = e.target.value;
      const opt = e.target.selectedOptions && e.target.selectedOptions[0];
      currentTopicName = opt ? opt.textContent : '';
      if (currentSource && currentChannel) await loadView(currentSource, currentChannel);
    };

    applyThemeByTime();
    setInterval(applyThemeByTime, 60 * 1000);
    loadSources();
  </script>
</body>
</html>
